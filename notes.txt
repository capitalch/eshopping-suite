//site for creating fake data in postgres
https://regilero.github.io/postgresql/english/2017/06/26/postgresql_advanced_generate_series/
//important sql's
//product generator
SELECT(
    SELECT concat_ws('',name_first, name_last, name_last1) as generated
    FROM (
        SELECT string_agg(x,'')
        FROM (
            select start_arr[ 1 + ( (random() * 25)::int) % 16 ]
            FROM
            (
                select '{CO,GE,FOR,SO,CO,GIM,SE,CO,GE,CA,FRA,GEC,GE,GA,FRO,GIP}'::text[] as start_arr
            ) syllarr,
            -- need 3 syllabes, and force generator interpretation with the '*0' (else 3 same syllabes)
            generate_series(1, 1 + (generator*0))
        ) AS comp3syl(x)
    ) AS comp_name_1st(name_first),
    
    (
        SELECT x[ 1 + ( (random() * 25)::int) % 14 ]
        FROM (
            select '{aLtd,a& Co,aSARL,aSA,aGmbh,aUnited,aBrothers,a& Sons,aInternational,aExt,aWorldwide,aGlobal,a2000,a3000}'::text[]
        ) AS z2(x)
    ) AS comp_name_last1(name_last1),
    
    (
        SELECT x[ 1 + ( (random() * 25)::int) % 14 ]
        FROM (
            select '{Ltd,& Co,SARL,SA,Gmbh,United,Brothers,& Sons,International,Ext,Worldwide,Global,2000,3000}'::text[]
        ) AS z2(x)
    ) AS comp_name_last(name_last)
    )
FROM generate_series(1,1) as generator

//search based recursive query to return all children
with recursive 
cte1 as (
	SELECT id, label, parent_id
        FROM category
            WHERE to_tsvector('english', label) @@ to_tsquery('english', 'lamb')
), 
cte2 as(
	select id, label, 
    CASE
    	WHEN parent_id in(select id from cte1)
    	then parent_id
    	else null::int
    END as parent_id
    from cte1
) , 
cte3 as(  
    select id, label, parent_id from cte2 
    union all
    	select c1.id, c1.label, c1.parent_id
    		from category c1 inner join cte3 c3
    			on c1.parent_id = c3.id
) select * from cte3 order by id;

with recursive cte1 as(
	(select id, label, cast(nullif(NULL, '') AS int) as parent_id
    	from category where id <=300 limit 100)
    union all
    select c1.id, c1.label, c1.parent_id
    	from category c1 inner join cte1 c2
    		on c1.parent_id = c2.id
) select distinct(id), label, parent_id from cte1 order by id ;

//----------------------------------------------------------------------------------
'post:query:categories:product:on:input2':`create temporary table temp1 (id int not null, label text, parent_id int,cat_cnt int, product_cnt int) on commit drop;  
  insert into temp1 
          with recursive 
        cte1 as (
          SELECT id, label, parent_id
                FROM category
                    WHERE 
                    to_tsvector('english', label) @@ to_tsquery('english', %L)
        ), 
        cte2 as(
          select id, label, 
            CASE
              WHEN parent_id in(select id from cte1)
              then parent_id
              else null::int
            END as parent_id
            from cte1
        ) , 
        cte3 as(  
            select id, label, parent_id from cte2 
            union all
              select c1.id, c1.label, c1.parent_id
                from category c1 inner join cte3 c3
                  on c1.parent_id = c3.id
        ) ,
        cte4 as (select c1.id, c1.label, c1.parent_id, sum(CASE WHEN c2.id is null then 0 else 1 end) as cat_cnt	
              from cte3 c1 left outer join cte3 c2 
                  on c1.id = c2.parent_id
                      group by c1.id, c1.label, c1.parent_id
                        order by c1.id),
        cte5 as (select c1.id, c1.label, c1.parent_id, min(c1.cat_cnt) as cat_cnt,
                sum(CASE WHEN p.id is null then 0 else 1 end) as product_cnt
                  from cte4 c1 left outer join product p   	
                      on c1.id = p.cat_id
                          group by c1.id, c1.label, c1.parent_id
                            order by c1
                            .id)
        select c2.id, c2.label || ' (' || 
                CASE WHEN c2.cat_cnt = 0 then c2.product_cnt else c2.cat_cnt END
                || ')' as label, c2.parent_id, c2.cat_cnt,c2.product_cnt from cte5 c2;
         update temp1 t set parent_id = -1 where t.parent_id is null;
         insert into temp1(id,label,parent_id,cat_cnt,product_cnt) values (-1,'Categories',null,0,0);
     select id,label,parent_id,cat_cnt,product_cnt from temp1 t order by t.id;`

//--------------------------------------------------------------------------------------------------------
  , 'post:query:products:on:category1': `select * from product where cat_id = %s;`            
  , 'post:query:categories:product:on:input1': `with cte2 as (
    with cte1 as (
        SELECT id, label, cast(nullif(NULL, '') AS int) as parent_id,
        COALESCE(parent_id,0) as id2
      FROM category WHERE id in(
       SELECT id
       FROM category
      WHERE to_tsvector('english', label) @@ to_tsquery('english', %L)
    ))
    select id,label,parent_id ,
      CASE min(id2)
          WHEN 0
              then 0
          ELSE
              count(id)
          END as cat_cnt
      from cte1 
          group by id,label,parent_id 
          order by id
  )
    select c2.id, label || ' (' || 
      CASE
      WHEN min(cat_cnt) = 0 
      then count(p.id)
      ELSE min(cat_cnt)
      end
      || ')' as label,parent_id, min(cat_cnt) as cat_cnt,  count(p.id) as product_cnt
      from cte2 c2
          left join product p
              on c2.id = p.cat_id
                  group by c2.id,label,parent_id
                    order by c2.id;`
//--------------------------------------------------------------------------------------------------------
  , genre1: `WITH RECURSIVE genres_materialized_path AS (
        SELECT id, name, ARRAY[]::INTEGER[] AS path
        FROM genres WHERE parent_id IS NULL
      
        UNION ALL
      
        SELECT genres.id, genres.name, genres_materialized_path.path || genres.parent_id
        FROM genres, genres_materialized_path
        WHERE genres.parent_id = genres_materialized_path.id
      ) SELECT * FROM genres_materialized_path WHERE 15 = genres_materialized_path.path[array_upper(genres_materialized_path.path,1)];`
  , emp: `with recursive cte1 as (
        select id, name, parent_id from emp where parent_id is null
          
          union all
          
          select e.id, e.name, e.parent_id from emp e
            inner join cte1 c
              on e.parent_id = c.id                    
      ) select * from cte1 order by id;`
  , emp1: `WITH RECURSIVE cte1 AS (
        SELECT id, name, parent_id,ARRAY[]::INTEGER[] AS path
        FROM emp WHERE parent_id IS NULL
      
        UNION ALL
      
        SELECT emp.id, emp.name, emp.parent_id, cte1.path || emp.parent_id
        FROM emp, cte1
        WHERE emp.parent_id = cte1.id
      ) SELECT * FROM cte1;`
  , mockCnt: `WITH RECURSIVE cte1 AS (
    SELECT id, label, parent_id,0 AS cnt
    FROM mock_data WHERE parent_id IS NULL
  
    UNION ALL
  
    SELECT mock.id, mock.label, mock.parent_id, cte1.cnt + 1
    FROM mock_data mock, cte1
    WHERE mock.parent_id = cte1.id
  ) SELECT * FROM cte1;`
//------------------------------------------------------------------------------------------------------
  , multiSql:`
  with cte1 as(
    SELECT id, label,  parent_id
       FROM cats
         WHERE to_tsvector('english', label) @@ to_tsquery('english', 'pork')
  ) select * into temp11 from cte1;
  
//------------------------------------------------------------------------------------------------------
drop table temp1,temp2;
select c1.id, c1.label, c1.parent_id, sum(CASE WHEN c2.id is null then 0 else 1 end) as cat_count	
    into temp1
	from cats c1 left outer join cats c2 
    	on c1.id = c2.parent_id
        	group by c1.id
        		order by c1.id;

select t.id, t.label, t.parent_id, t.cat_count,
sum(CASE WHEN p.id is null then 0 else 1 end) as product_count into temp2
	from temp1 t left outer join product p
    	
    	on t.id = p.cat_id
        	group by t.id, t.label, t.parent_id, t.cat_count
        		order by t.id;
select id, t.label || ' (' || 
CASE WHEN t.cat_count = 0 then t.product_count else t.cat_count end

|| ')' as label, parent_id from temp2 t

//------------------------------------------------------------------------------------------------------
select c1.id, c1.label, c1.parent_id, count(c1.id) as child_cnt
	from cats c1 left outer join cats c2
    	on c1.id = c2.parent_id
        	group by c1.id
        		order by c1.id
//------------------------------------------------------------------------------------------------------
with cte2 as (
    with cte1 as (
        SELECT id, label, cast(nullif(NULL, '') AS int) as parent_id,
        COALESCE(parent_id,0) as id2
      FROM cats WHERE id in(
       SELECT id
       FROM cats
      --WHERE to_tsvector('english', label) @@ to_tsquery('english', '')
    ))
    select id,label,parent_id ,
      CASE min(id2)
          WHEN 0
              then 0
          ELSE
              count(id)
          END as cat_cnt
      from cte1 
          group by id,label,parent_id 
          order by id
  )
    select c2.id, label || ' (' || 
      CASE
      WHEN min(cat_cnt) = 0 
      then count(p.id)
      ELSE min(cat_cnt)
      end
      || ')' as label,parent_id, min(cat_cnt) as cat_cnt,  count(p.id) as product_cnt
      from cte2 c2
          left join product p
              on c2.id = p.cat_id
                  group by c2.id,label,parent_id
                    order by c2.id;
//-------------------------------------------------------------------------------------------------------
with cte2 as (
    with cte1 as (
      select c1.id,c1.label,c1.parent_id, 
        COALESCE(c2.id,0) as id2 
          from category c1 left join category c2 on c1.id = c2.parent_id
    )
    select id,label,parent_id ,
      CASE min(id2)
          WHEN 0
              then 0
          ELSE
              count(id)
          END as cat_cnt
      from cte1 
          group by id,label,parent_id 
          order by id
  )
    select c2.id, label || ' (' || 
      CASE
      WHEN min(cat_cnt) = 0 
      then count(p.id)
      ELSE min(cat_cnt)
      end
      || ')' as label,parent_id, min(cat_cnt) as cat_cnt,  count(p.id) as product_cnt
      from cte2 c2
          left join product p
              on c2.id = p.cat_id
                  group by c2.id,label,parent_id
                    order by c2.id;


https://www.mockaroo.com/
Formula type for random images
'https://robohash.org/' + format(random(1,10000),0) + '.png?size=250x250&set=set1'  
//good angular 2 tree and many other libraries
https://libraries.io/explore/typescript-angular2-libraries?keywords=4%2CAngular+4%2Cangular+2%2Ctree%2Cangular-treeview%2Cangular+4&licenses=MIT%2CGPL-2.0&platforms=NPM
// Angular 2 tree
https://angular2-tree.readme.io/docs
//wijmo
http://demos.wijmo.com/5/Angular2/TreeViewIntro/TreeViewIntro/
//creating tree from scratch. good one
https://blog.imaginea.com/render-an-infinite-tree-in-angular-2/
//ngx-treeview good one
https://devarchy.com/angular/ngx-treeview
//JQWidgets
https://www.jqwidgets.com/angular/?gclid=EAIaIQobChMIqoGur-DH1wIVWB0rCh1_eww0EAMYASAAEgKZT_D_BwE
//ng2-tree
https://github.com/valor-software/ng2-tree#eyes-demo
//prime-ng
https://www.primefaces.org/primeng/#/tree